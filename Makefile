.PHONY: all graphics plot doc ospi

OSPI_ROOT ?= $(shell pwd)
OCAMLRUNPARAM := $(OCAMLRUNPARAM)b

export OSPI_ROOT OCAMLRUNPARAM

ALL_BASE_LIB_TARGETS := graphics/gr
ALL_LIB_TARGETS := $(foreach ext,d.cma cma cmxa p.cmxa,$(addsuffix .$(ext),$(ALL_BASE_LIB_TARGETS)))

DIRS := syntax proto hivemind cells graphics graph n-body
TEST_SOURCE := $(shell find $(DIRS) -name 'test_*.ml')
TEST_BASES := $(TEST_SOURCE:%.ml=%)
ALL_TEST_TARGETS := $(TEST_SOURCE:%.ml=%.passed)

OSPI_TEST_SOURCE := $(shell find ospi -name 'test_*.ml')
OSPI_TEST_BASES := $(OSPI_TEST_SOURCE:%.ml=%)
OSPI_ALL_TEST_TARGETS := $(OSPI_TEST_SOURCE:%.ml=%.native.passed)

# n-body/serial_nbody n-body/serial_raytracer
PROG_BASE_EXE_TARGETS := hivemind/demo_chord_gtk hivemind/demo_chord hivemind/hm proto2/main proto2/ocs_window graphics/sutra_example proto2/lemmy_window n-body/nbody n-body/nbody_worker graph/placement_test graph/bookshelf_main n-body/parallel_nbody n-body/parallel_raytracer mpi/timelineDisplay mpi/timelineAnalysis graph/placement_demo graph/placement_gui graph/aux2hgraph graphics/cairo_server_main graphics/cairo_worker_main graphics/parallel_render_demo graph/placement_sg_worker graph/text_of_hgraph
ALL_BASE_EXE_TARGETS := $(TEST_BASES) $(PROG_BASE_EXE_TARGETS)
ALL_EXE_TARGETS := $(foreach ext,d.byte byte native p.native,$(addsuffix .$(ext),$(ALL_BASE_EXE_TARGETS)))

OCAMLBUILD_FLAGS += $(if $(filter dumb,$(TERM)),-classic-display)

ALL_TOP_TARGETS := hivemind.top
ALL_DOC_TARGETS := doc.docdir/index.html
ALL_TARGETS := $(ALL_EXE_TARGETS) $(ALL_LIB_TARGETS) $(ALL_TOP_TARGETS) $(ALL_DOC_TARGETS) $(ALL_TEST_TARGETS)
all: force
	ocamlbuild $(OCAMLBUILD_FLAGS) $(ALL_TARGETS)
byte: force
	ocamlbuild $(OCAMLBUILD_FLAGS) $(addsuffix .byte,$(PROG_BASE_EXE_TARGETS))
d.byte: force
	ocamlbuild $(OCAMLBUILD_FLAGS) $(addsuffix .d.byte,$(PROG_BASE_EXE_TARGETS))
native: force
	ocamlbuild $(OCAMLBUILD_FLAGS) $(addsuffix .native,$(PROG_BASE_EXE_TARGETS))
p.native: force
	ocamlbuild $(OCAMLBUILD_FLAGS) $(addsuffix .p.native,$(PROG_BASE_EXE_TARGETS))

$(ALL_TARGETS): force
	ocamlbuild $(OCAMLBUILD_FLAGS) $(@)

# depending on this makes the actions guaranteed to run
force: ;

tests: force
	ocamlbuild $(OCAMLBUILD_FLAGS) $(ALL_TEST_TARGETS)

ospi_tests: force
	ocamlbuild $(OCAMLBUILD_FLAGS) $(OSPI_ALL_TEST_TARGETS)

.PHONY: tests top

top: force
	ocamlbuild $(OCAMLBUILD_FLAGS) $(ALL_TOP_TARGETS)
	export OCAMLRUNPARAM=b; rlwrap ./hivemind.top $(shell for n in `find _build -name '*.cmi'`; do dirname $$n; done | sort -u | sed -e 's/^/-I /')

doc: force
	ocamlbuild $(OCAMLBUILD_FLAGS) $(ALL_DOC_TARGETS)

# Simple cleanup
clean::
	ocamlbuild $(OCAMLBUILD_FLAGS) -clean

PDTYPE=d.byte

graphics: _build/graphics/gr.cma

OSPI_TARGETS := $(addprefix _build/,$(foreach ext,d.byte byte native p.native,$(addsuffix .$(ext),ospi/demo ospi/test_sim)))
$(OSPI_TARGETS): OCAMLBUILD_FLAGS += -I proto
ospi: _build/ospi/demo.byte _build/ospi/test_sim.byte

sutra: _build/graphics/sutra_example.byte \
       _build/graphics/sutra_anim_eg.byte \
       _build/graphics/sutra_logo.byte \
       _build/graphics/test_sutra.byte \
       _build/graphics/bench_sutra.byte

plot: _build/plot/spline.native _build/plot/plot_surface.native \
      _build/plot/test_widgets.byte _build/plot/test_plot_widget.byte

# tests: _build/test_all_suite.byte
# 	./$<

# All of our internal documentation generated by muse
muse-docs:
	mkdir -p doc/wiki doc/articles doc/raw doc/publish
	test -h `pwd`/doc/static || ln -s `pwd`/doc-src/static `pwd`/doc/static
	make -C ../../benchmark whitepaper
	test -h `pwd`/doc/images || ln -s $(shell cd ../../benchmark/whitepaper/doc/images && pwd) `pwd`/doc/images
	test -h `pwd`/doc-src/images || ln -s $(shell cd ../../benchmark/whitepaper/doc/images && pwd) `pwd`/doc-src/images
	emacs -q -batch -l ../../etc/elisp/muse-init.el \
	  -f muse-project-batch-publish "Wiki" "Raw" "Articles" "Publish"
muse-slides:
	mkdir -p doc/slides
	emacs -q -batch -l ../../etc/elisp/muse-init.el \
	  -f muse-project-batch-publish "Slides"


